/*
SmartFabric Storage Software Application REST APIs

REST APIs used for managing SFSS application are captured in this section.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sfssapp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiDeleteRedfishV1SFSSAppAlertsCDCInstanceManagersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uuid       string
}

func (r ApiDeleteRedfishV1SFSSAppAlertsCDCInstanceManagersRequest) Execute() (*DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers200Response, *http.Response, error) {
	return r.ApiService.DeleteRedfishV1SFSSAppAlertsCDCInstanceManagersExecute(r)
}

/*
DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers Delete alert

This API removes the specified alert from the SFSS application based on the alert identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid Alert UUID
	@return ApiDeleteRedfishV1SFSSAppAlertsCDCInstanceManagersRequest
*/
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers(ctx context.Context, uuid string) ApiDeleteRedfishV1SFSSAppAlertsCDCInstanceManagersRequest {
	return ApiDeleteRedfishV1SFSSAppAlertsCDCInstanceManagersRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
//
//	@return DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers200Response
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppAlertsCDCInstanceManagersExecute(r ApiDeleteRedfishV1SFSSAppAlertsCDCInstanceManagersRequest) (*DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRedfishV1SFSSAppAlertsCDCInstanceManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Alerts({uuid})"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRedfishV1SFSSAppCDCInstanceManagersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	instanceId string
}

func (r ApiDeleteRedfishV1SFSSAppCDCInstanceManagersRequest) Execute() (*PostRedfishV1SFSSAppFabricManagerInfoPost200Response, *http.Response, error) {
	return r.ApiService.DeleteRedfishV1SFSSAppCDCInstanceManagersExecute(r)
}

/*
DeleteRedfishV1SFSSAppCDCInstanceManagers Delete CDC instance

This API removes the specified CDC instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param instanceId InstanceIdentifier
	@return ApiDeleteRedfishV1SFSSAppCDCInstanceManagersRequest
*/
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppCDCInstanceManagers(ctx context.Context, instanceId string) ApiDeleteRedfishV1SFSSAppCDCInstanceManagersRequest {
	return ApiDeleteRedfishV1SFSSAppCDCInstanceManagersRequest{
		ApiService: a,
		ctx:        ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppFabricManagerInfoPost200Response
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppCDCInstanceManagersExecute(r ApiDeleteRedfishV1SFSSAppCDCInstanceManagersRequest) (*PostRedfishV1SFSSAppFabricManagerInfoPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppFabricManagerInfoPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRedfishV1SFSSAppCDCInstanceManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCInstanceManagers({InstanceId})"
	localVarPath = strings.Replace(localVarPath, "{"+"InstanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRedfishV1SFSSAppIpAddressManagementsRequest struct {
	ctx         context.Context
	ApiService  *DefaultAPIService
	interfaceId string
}

func (r ApiDeleteRedfishV1SFSSAppIpAddressManagementsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRedfishV1SFSSAppIpAddressManagementsExecute(r)
}

/*
DeleteRedfishV1SFSSAppIpAddressManagements Delete VLAN interface

This API removes the specified interface from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param interfaceId Vlan interface Name
	@return ApiDeleteRedfishV1SFSSAppIpAddressManagementsRequest
*/
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppIpAddressManagements(ctx context.Context, interfaceId string) ApiDeleteRedfishV1SFSSAppIpAddressManagementsRequest {
	return ApiDeleteRedfishV1SFSSAppIpAddressManagementsRequest{
		ApiService:  a,
		ctx:         ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppIpAddressManagementsExecute(r ApiDeleteRedfishV1SFSSAppIpAddressManagementsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRedfishV1SFSSAppIpAddressManagements")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements({InterfaceId})"
	localVarPath = strings.Replace(localVarPath, "{"+"InterfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRedfishV1SFSSAppNTPServerIPRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	serverIP   string
}

func (r ApiDeleteRedfishV1SFSSAppNTPServerIPRequest) Execute() (*DeleteRedfishV1SFSSAppNTPServerIP200Response, *http.Response, error) {
	return r.ApiService.DeleteRedfishV1SFSSAppNTPServerIPExecute(r)
}

/*
DeleteRedfishV1SFSSAppNTPServerIP Remove NTP configuration

This API removes the NTP server configuration from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverIP IP address of the NTP server
	@return ApiDeleteRedfishV1SFSSAppNTPServerIPRequest
*/
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppNTPServerIP(ctx context.Context, serverIP string) ApiDeleteRedfishV1SFSSAppNTPServerIPRequest {
	return ApiDeleteRedfishV1SFSSAppNTPServerIPRequest{
		ApiService: a,
		ctx:        ctx,
		serverIP:   serverIP,
	}
}

// Execute executes the request
//
//	@return DeleteRedfishV1SFSSAppNTPServerIP200Response
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppNTPServerIPExecute(r ApiDeleteRedfishV1SFSSAppNTPServerIPRequest) (*DeleteRedfishV1SFSSAppNTPServerIP200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteRedfishV1SFSSAppNTPServerIP200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRedfishV1SFSSAppNTPServerIP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/NTP({ServerIP})"
	localVarPath = strings.Replace(localVarPath, "{"+"ServerIP"+"}", url.PathEscape(parameterValueToString(r.serverIP, "serverIP")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRedfishV1SFSSAppSFSSImagesRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	versiontbd *string
}

// ImageId
func (r ApiDeleteRedfishV1SFSSAppSFSSImagesRequest) Versiontbd(versiontbd string) ApiDeleteRedfishV1SFSSAppSFSSImagesRequest {
	r.versiontbd = &versiontbd
	return r
}

func (r ApiDeleteRedfishV1SFSSAppSFSSImagesRequest) Execute() (*PutRedfishV1SFSSApp200Response, *http.Response, error) {
	return r.ApiService.DeleteRedfishV1SFSSAppSFSSImagesExecute(r)
}

/*
DeleteRedfishV1SFSSAppSFSSImages Delete image

This API is used to delete the specified image from the SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteRedfishV1SFSSAppSFSSImagesRequest
*/
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppSFSSImages(ctx context.Context) ApiDeleteRedfishV1SFSSAppSFSSImagesRequest {
	return ApiDeleteRedfishV1SFSSAppSFSSImagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PutRedfishV1SFSSApp200Response
func (a *DefaultAPIService) DeleteRedfishV1SFSSAppSFSSImagesExecute(r ApiDeleteRedfishV1SFSSAppSFSSImagesRequest) (*PutRedfishV1SFSSApp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutRedfishV1SFSSApp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteRedfishV1SFSSAppSFSSImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSImages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.versiontbd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versiontbd", r.versiontbd, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsRequest) Execute() (*GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums200Response, *http.Response, error) {
	return r.ApiService.GetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsExecute(r)
}

/*
GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums Get interface enums

This API retreives all supported enumerations for the IP address management API to configure interfaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsRequest
*/
func (a *DefaultAPIService) GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums(ctx context.Context) ApiGetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsRequest {
	return ApiGetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums200Response
func (a *DefaultAPIService) GetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsExecute(r ApiGetEnumsRedfishV1SFSSAppIpAddressManagementsEnumsRequest) (*GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetEnumsRedfishV1SFSSAppIpAddressManagementsEnums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements/Enums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpandRedfishV1SFSSAppBackupsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetExpandRedfishV1SFSSAppBackupsRequest) Execute() (*GetExpandRedfishV1SFSSAppBackups200Response, *http.Response, error) {
	return r.ApiService.GetExpandRedfishV1SFSSAppBackupsExecute(r)
}

/*
GetExpandRedfishV1SFSSAppBackups Get all backups

This API retrieves detailed backup information available in SFSS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExpandRedfishV1SFSSAppBackupsRequest
*/
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppBackups(ctx context.Context) ApiGetExpandRedfishV1SFSSAppBackupsRequest {
	return ApiGetExpandRedfishV1SFSSAppBackupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetExpandRedfishV1SFSSAppBackups200Response
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppBackupsExecute(r ApiGetExpandRedfishV1SFSSAppBackupsRequest) (*GetExpandRedfishV1SFSSAppBackups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExpandRedfishV1SFSSAppBackups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetExpandRedfishV1SFSSAppBackups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Backups?$expand=Backups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandRequest) Execute() (*GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand200Response, *http.Response, error) {
	return r.ApiService.GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandExecute(r)
}

/*
GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand Get all foundational configuration

This API retrieves all the foundational configuration information from the SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandRequest
*/
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand(ctx context.Context) ApiGetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandRequest {
	return ApiGetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand200Response
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandExecute(r ApiGetExpandRedfishV1SFSSAppFoundationalConfigsGETExpandRequest) (*GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetExpandRedfishV1SFSSAppFoundationalConfigsGETExpand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/FoundationalConfigs?$expand=FoundationalConfigs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpandRedfishV1SFSSAppIpAddressManagementsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetExpandRedfishV1SFSSAppIpAddressManagementsRequest) Execute() (*GetExpandRedfishV1SFSSAppIpAddressManagements200Response, *http.Response, error) {
	return r.ApiService.GetExpandRedfishV1SFSSAppIpAddressManagementsExecute(r)
}

/*
GetExpandRedfishV1SFSSAppIpAddressManagements Get all interfaces

This API retrieves detailed information about all the interfaces configured in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExpandRedfishV1SFSSAppIpAddressManagementsRequest
*/
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppIpAddressManagements(ctx context.Context) ApiGetExpandRedfishV1SFSSAppIpAddressManagementsRequest {
	return ApiGetExpandRedfishV1SFSSAppIpAddressManagementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetExpandRedfishV1SFSSAppIpAddressManagements200Response
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppIpAddressManagementsExecute(r ApiGetExpandRedfishV1SFSSAppIpAddressManagementsRequest) (*GetExpandRedfishV1SFSSAppIpAddressManagements200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExpandRedfishV1SFSSAppIpAddressManagements200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetExpandRedfishV1SFSSAppIpAddressManagements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements?$expand=IpAddressManagements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpandRedfishV1SFSSAppRestoresRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetExpandRedfishV1SFSSAppRestoresRequest) Execute() (*GetExpandRedfishV1SFSSAppRestores200Response, *http.Response, error) {
	return r.ApiService.GetExpandRedfishV1SFSSAppRestoresExecute(r)
}

/*
GetExpandRedfishV1SFSSAppRestores Get detailed restore information

This API retrieves detailed information about the restored data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExpandRedfishV1SFSSAppRestoresRequest
*/
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppRestores(ctx context.Context) ApiGetExpandRedfishV1SFSSAppRestoresRequest {
	return ApiGetExpandRedfishV1SFSSAppRestoresRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetExpandRedfishV1SFSSAppRestores200Response
func (a *DefaultAPIService) GetExpandRedfishV1SFSSAppRestoresExecute(r ApiGetExpandRedfishV1SFSSAppRestoresRequest) (*GetExpandRedfishV1SFSSAppRestores200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetExpandRedfishV1SFSSAppRestores200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetExpandRedfishV1SFSSAppRestores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Restores?$expand=Restores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIDRedfishV1SFSSAppRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	version    string
}

func (r ApiGetIDRedfishV1SFSSAppRequest) Execute() (*GetIDRedfishV1SFSSApp200Response, *http.Response, error) {
	return r.ApiService.GetIDRedfishV1SFSSAppExecute(r)
}

/*
GetIDRedfishV1SFSSApp Get specific image

This API retrieves information about the specified SFSS image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param version The version of the SFSS image to retrieve information for.
	@return ApiGetIDRedfishV1SFSSAppRequest
*/
func (a *DefaultAPIService) GetIDRedfishV1SFSSApp(ctx context.Context, version string) ApiGetIDRedfishV1SFSSAppRequest {
	return ApiGetIDRedfishV1SFSSAppRequest{
		ApiService: a,
		ctx:        ctx,
		version:    version,
	}
}

// Execute executes the request
//
//	@return GetIDRedfishV1SFSSApp200Response
func (a *DefaultAPIService) GetIDRedfishV1SFSSAppExecute(r ApiGetIDRedfishV1SFSSAppRequest) (*GetIDRedfishV1SFSSApp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIDRedfishV1SFSSApp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetIDRedfishV1SFSSApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSImages({version})"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIDRedfishV1SFSSAppRadiusServersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iP         string
}

func (r ApiGetIDRedfishV1SFSSAppRadiusServersRequest) Execute() (*GetIDRedfishV1SFSSAppRadiusServers200Response, *http.Response, error) {
	return r.ApiService.GetIDRedfishV1SFSSAppRadiusServersExecute(r)
}

/*
GetIDRedfishV1SFSSAppRadiusServers Get specific RADIUS server

This API retrieves information about the specified RADIUS server based on the IP address.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iP IP address of the RADIUS server
	@return ApiGetIDRedfishV1SFSSAppRadiusServersRequest
*/
func (a *DefaultAPIService) GetIDRedfishV1SFSSAppRadiusServers(ctx context.Context, iP string) ApiGetIDRedfishV1SFSSAppRadiusServersRequest {
	return ApiGetIDRedfishV1SFSSAppRadiusServersRequest{
		ApiService: a,
		ctx:        ctx,
		iP:         iP,
	}
}

// Execute executes the request
//
//	@return GetIDRedfishV1SFSSAppRadiusServers200Response
func (a *DefaultAPIService) GetIDRedfishV1SFSSAppRadiusServersExecute(r ApiGetIDRedfishV1SFSSAppRadiusServersRequest) (*GetIDRedfishV1SFSSAppRadiusServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIDRedfishV1SFSSAppRadiusServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetIDRedfishV1SFSSAppRadiusServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/RadiusServers({IP})"
	localVarPath = strings.Replace(localVarPath, "{"+"IP"+"}", url.PathEscape(parameterValueToString(r.iP, "iP")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIDRedfishV1SFSSAppTacacsServersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iP         string
}

func (r ApiGetIDRedfishV1SFSSAppTacacsServersRequest) Execute() (*GetIDRedfishV1SFSSAppTacacsServers200Response, *http.Response, error) {
	return r.ApiService.GetIDRedfishV1SFSSAppTacacsServersExecute(r)
}

/*
GetIDRedfishV1SFSSAppTacacsServers Get specific TACACS+ server

This API retrieves information about the specific TACACS+ server based on the TACACS+ server IP address.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iP IP address of the TACACS+ server
	@return ApiGetIDRedfishV1SFSSAppTacacsServersRequest
*/
func (a *DefaultAPIService) GetIDRedfishV1SFSSAppTacacsServers(ctx context.Context, iP string) ApiGetIDRedfishV1SFSSAppTacacsServersRequest {
	return ApiGetIDRedfishV1SFSSAppTacacsServersRequest{
		ApiService: a,
		ctx:        ctx,
		iP:         iP,
	}
}

// Execute executes the request
//
//	@return GetIDRedfishV1SFSSAppTacacsServers200Response
func (a *DefaultAPIService) GetIDRedfishV1SFSSAppTacacsServersExecute(r ApiGetIDRedfishV1SFSSAppTacacsServersRequest) (*GetIDRedfishV1SFSSAppTacacsServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIDRedfishV1SFSSAppTacacsServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetIDRedfishV1SFSSAppTacacsServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/TacacsServers({IP})"
	localVarPath = strings.Replace(localVarPath, "{"+"IP"+"}", url.PathEscape(parameterValueToString(r.iP, "iP")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iP) < 1 {
		return localVarReturnValue, nil, reportError("iP must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIDredfishV1SFSSAppSFSSInterfaceListRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetIDredfishV1SFSSAppSFSSInterfaceListRequest) Execute() (*GetIDredfishV1SFSSAppSFSSInterfaceList200Response, *http.Response, error) {
	return r.ApiService.GetIDredfishV1SFSSAppSFSSInterfaceListExecute(r)
}

/*
GetIDredfishV1SFSSAppSFSSInterfaceList Get all interfaces

This API retrieves a list of available interfaces in SFSS application. This API is applicable only for standalone virtual machine deployments.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIDredfishV1SFSSAppSFSSInterfaceListRequest
*/
func (a *DefaultAPIService) GetIDredfishV1SFSSAppSFSSInterfaceList(ctx context.Context) ApiGetIDredfishV1SFSSAppSFSSInterfaceListRequest {
	return ApiGetIDredfishV1SFSSAppSFSSInterfaceListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetIDredfishV1SFSSAppSFSSInterfaceList200Response
func (a *DefaultAPIService) GetIDredfishV1SFSSAppSFSSInterfaceListExecute(r ApiGetIDredfishV1SFSSAppSFSSInterfaceListRequest) (*GetIDredfishV1SFSSAppSFSSInterfaceList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetIDredfishV1SFSSAppSFSSInterfaceList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetIDredfishV1SFSSAppSFSSInterfaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSInterfaceList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppRequest) Execute() (*GetRedfishV1SFSSApp200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppExecute(r)
}

/*
GetRedfishV1SFSSApp Get SFSS application details

This API retrieves information about the SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSApp(ctx context.Context) ApiGetRedfishV1SFSSAppRequest {
	return ApiGetRedfishV1SFSSAppRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSApp200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppExecute(r ApiGetRedfishV1SFSSAppRequest) (*GetRedfishV1SFSSApp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSApp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppAlertsAlertIdRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	uuid       string
}

func (r ApiGetRedfishV1SFSSAppAlertsAlertIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppAlertsAlertIdExecute(r)
}

/*
GetRedfishV1SFSSAppAlertsAlertId Get specific alert

This API retrieves information about a specific alert based on the alert identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid Alert UUID
	@return ApiGetRedfishV1SFSSAppAlertsAlertIdRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppAlertsAlertId(ctx context.Context, uuid string) ApiGetRedfishV1SFSSAppAlertsAlertIdRequest {
	return ApiGetRedfishV1SFSSAppAlertsAlertIdRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetRedfishV1SFSSAppAlertsAlertIdExecute(r ApiGetRedfishV1SFSSAppAlertsAlertIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppAlertsAlertId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Alerts({uuid})"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppAuthenticationSequenceRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppAuthenticationSequenceRequest) Execute() (*GetRedfishV1SFSSAppAuthenticationSequence200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppAuthenticationSequenceExecute(r)
}

/*
GetRedfishV1SFSSAppAuthenticationSequence Get authentication sequence

This API retrieves authentication sequence information for SFSS application authentication.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppAuthenticationSequenceRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppAuthenticationSequence(ctx context.Context) ApiGetRedfishV1SFSSAppAuthenticationSequenceRequest {
	return ApiGetRedfishV1SFSSAppAuthenticationSequenceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppAuthenticationSequence200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppAuthenticationSequenceExecute(r ApiGetRedfishV1SFSSAppAuthenticationSequenceRequest) (*GetRedfishV1SFSSAppAuthenticationSequence200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppAuthenticationSequence200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppAuthenticationSequence")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/AuthenticationSequence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppAuthenticationSequenceEnumsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppAuthenticationSequenceEnumsRequest) Execute() (*GetRedfishV1SFSSAppAuthenticationSequenceEnums200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppAuthenticationSequenceEnumsExecute(r)
}

/*
GetRedfishV1SFSSAppAuthenticationSequenceEnums Get authentication sequence enums

This API retrieves all the supported enumerations for the authentication sequence.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppAuthenticationSequenceEnumsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppAuthenticationSequenceEnums(ctx context.Context) ApiGetRedfishV1SFSSAppAuthenticationSequenceEnumsRequest {
	return ApiGetRedfishV1SFSSAppAuthenticationSequenceEnumsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppAuthenticationSequenceEnums200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppAuthenticationSequenceEnumsExecute(r ApiGetRedfishV1SFSSAppAuthenticationSequenceEnumsRequest) (*GetRedfishV1SFSSAppAuthenticationSequenceEnums200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppAuthenticationSequenceEnums200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppAuthenticationSequenceEnums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/AuthenticationSequence/Enums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppBackupsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppBackupsRequest) Execute() (*GetRedfishV1SFSSAppBackups200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppBackupsExecute(r)
}

/*
GetRedfishV1SFSSAppBackups Get all backups

This API retrieves all the available backups from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppBackupsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppBackups(ctx context.Context) ApiGetRedfishV1SFSSAppBackupsRequest {
	return ApiGetRedfishV1SFSSAppBackupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppBackups200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppBackupsExecute(r ApiGetRedfishV1SFSSAppBackupsRequest) (*GetRedfishV1SFSSAppBackups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppBackups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppBackups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Backups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppBackupsIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iD         string
}

func (r ApiGetRedfishV1SFSSAppBackupsIDRequest) Execute() (*GetRedfishV1SFSSAppBackupsID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppBackupsIDExecute(r)
}

/*
GetRedfishV1SFSSAppBackupsID Get specific backup

This API retrieves information about a backup operation based on the specified backup id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iD Backup identifier
	@return ApiGetRedfishV1SFSSAppBackupsIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppBackupsID(ctx context.Context, iD string) ApiGetRedfishV1SFSSAppBackupsIDRequest {
	return ApiGetRedfishV1SFSSAppBackupsIDRequest{
		ApiService: a,
		ctx:        ctx,
		iD:         iD,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppBackupsID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppBackupsIDExecute(r ApiGetRedfishV1SFSSAppBackupsIDRequest) (*GetRedfishV1SFSSAppBackupsID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppBackupsID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppBackupsID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Backups({ID})"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iD) < 1 {
		return localVarReturnValue, nil, reportError("iD must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppCDCHealthStatusRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppCDCHealthStatusRequest) Execute() (*GetRedfishV1SFSSAppCDCHealthStatus200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppCDCHealthStatusExecute(r)
}

/*
GetRedfishV1SFSSAppCDCHealthStatus Get CDC health

This API retrieves health status information of the CDC instances running in SFSS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppCDCHealthStatusRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCHealthStatus(ctx context.Context) ApiGetRedfishV1SFSSAppCDCHealthStatusRequest {
	return ApiGetRedfishV1SFSSAppCDCHealthStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppCDCHealthStatus200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCHealthStatusExecute(r ApiGetRedfishV1SFSSAppCDCHealthStatusRequest) (*GetRedfishV1SFSSAppCDCHealthStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppCDCHealthStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppCDCHealthStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCHealthStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppCDCHealthStatusIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iD         string
}

func (r ApiGetRedfishV1SFSSAppCDCHealthStatusIDRequest) Execute() (*GetRedfishV1SFSSAppCDCHealthStatusID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppCDCHealthStatusIDExecute(r)
}

/*
GetRedfishV1SFSSAppCDCHealthStatusID Get specific CDC health

This API retrieves detailed health status of the specified CDC instance identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iD CDC instance identifier
	@return ApiGetRedfishV1SFSSAppCDCHealthStatusIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCHealthStatusID(ctx context.Context, iD string) ApiGetRedfishV1SFSSAppCDCHealthStatusIDRequest {
	return ApiGetRedfishV1SFSSAppCDCHealthStatusIDRequest{
		ApiService: a,
		ctx:        ctx,
		iD:         iD,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppCDCHealthStatusID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCHealthStatusIDExecute(r ApiGetRedfishV1SFSSAppCDCHealthStatusIDRequest) (*GetRedfishV1SFSSAppCDCHealthStatusID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppCDCHealthStatusID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppCDCHealthStatusID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCHealthStatus({ID})"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iD) < 1 {
		return localVarReturnValue, nil, reportError("iD must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	expand     *string
}

// CDCInstanceManagers
func (r ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest) Expand(expand string) ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest {
	r.expand = &expand
	return r
}

func (r ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest) Execute() (*GetRedfishV1SFSSAppCDCInstanceManagers200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppCDCInstanceManagersExecute(r)
}

/*
GetRedfishV1SFSSAppCDCInstanceManagers Get all CDCs

This API retrieves details about all the Centralized Discovery Controller (CDC) instances configured in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCInstanceManagers(ctx context.Context) ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest {
	return ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppCDCInstanceManagers200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCInstanceManagersExecute(r ApiGetRedfishV1SFSSAppCDCInstanceManagersRequest) (*GetRedfishV1SFSSAppCDCInstanceManagers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppCDCInstanceManagers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppCDCInstanceManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCInstanceManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "$expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppCDCInstanceManagersEnumsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppCDCInstanceManagersEnumsRequest) Execute() (*GetRedfishV1SFSSAppCDCInstanceManagersEnums200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppCDCInstanceManagersEnumsExecute(r)
}

/*
GetRedfishV1SFSSAppCDCInstanceManagersEnums Get CDC enums

This API retrieves all the supported enumerations for the CDC instance manager.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppCDCInstanceManagersEnumsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCInstanceManagersEnums(ctx context.Context) ApiGetRedfishV1SFSSAppCDCInstanceManagersEnumsRequest {
	return ApiGetRedfishV1SFSSAppCDCInstanceManagersEnumsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppCDCInstanceManagersEnums200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCInstanceManagersEnumsExecute(r ApiGetRedfishV1SFSSAppCDCInstanceManagersEnumsRequest) (*GetRedfishV1SFSSAppCDCInstanceManagersEnums200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppCDCInstanceManagersEnums200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppCDCInstanceManagersEnums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCInstanceManagers/Enums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppCDCInstanceManagersIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	instanceId int32
}

func (r ApiGetRedfishV1SFSSAppCDCInstanceManagersIDRequest) Execute() (*GetRedfishV1SFSSAppCDCInstanceManagersID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppCDCInstanceManagersIDExecute(r)
}

/*
GetRedfishV1SFSSAppCDCInstanceManagersID Get specific CDC information

This API retrieves information about the CDC instance based on the specified instance identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param instanceId The identifier of the CDC instance to retrieve information for.
	@return ApiGetRedfishV1SFSSAppCDCInstanceManagersIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCInstanceManagersID(ctx context.Context, instanceId int32) ApiGetRedfishV1SFSSAppCDCInstanceManagersIDRequest {
	return ApiGetRedfishV1SFSSAppCDCInstanceManagersIDRequest{
		ApiService: a,
		ctx:        ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppCDCInstanceManagersID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppCDCInstanceManagersIDExecute(r ApiGetRedfishV1SFSSAppCDCInstanceManagersIDRequest) (*GetRedfishV1SFSSAppCDCInstanceManagersID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppCDCInstanceManagersID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppCDCInstanceManagersID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCInstanceManagers({InstanceId})"
	localVarPath = strings.Replace(localVarPath, "{"+"InstanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.instanceId < 1 {
		return localVarReturnValue, nil, reportError("instanceId must be greater than 1")
	}
	if r.instanceId > 32 {
		return localVarReturnValue, nil, reportError("instanceId must be less than 32")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppDeviceRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	body       *map[string]interface{}
}

func (r ApiGetRedfishV1SFSSAppDeviceRequest) Body(body map[string]interface{}) ApiGetRedfishV1SFSSAppDeviceRequest {
	r.body = &body
	return r
}

func (r ApiGetRedfishV1SFSSAppDeviceRequest) Execute() (*GetRedfishV1SFSSAppDevice200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppDeviceExecute(r)
}

/*
GetRedfishV1SFSSAppDevice Get device details

This API retrieves device details from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppDeviceRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppDevice(ctx context.Context) ApiGetRedfishV1SFSSAppDeviceRequest {
	return ApiGetRedfishV1SFSSAppDeviceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppDevice200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppDeviceExecute(r ApiGetRedfishV1SFSSAppDeviceRequest) (*GetRedfishV1SFSSAppDevice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppDevice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppEnumsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppEnumsRequest) Execute() (*GetRedfishV1SFSSAppEnums200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppEnumsExecute(r)
}

/*
GetRedfishV1SFSSAppEnums Get image enums

This API lists all the supported enumerations for the SFSS image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppEnumsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppEnums(ctx context.Context) ApiGetRedfishV1SFSSAppEnumsRequest {
	return ApiGetRedfishV1SFSSAppEnumsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppEnums200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppEnumsExecute(r ApiGetRedfishV1SFSSAppEnumsRequest) (*GetRedfishV1SFSSAppEnums200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppEnums200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppEnums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSImages/Enums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppEventsRequest struct {
	ctx                  context.Context
	ApiService           *DefaultAPIService
	top2                 *int32
	filterCDCInstanceEq1 *string
}

// This parameter is used in pagination logic to fetch the top two records.
func (r ApiGetRedfishV1SFSSAppEventsRequest) Top2(top2 int32) ApiGetRedfishV1SFSSAppEventsRequest {
	r.top2 = &top2
	return r
}

// This parameter is used to fetch the specific record that matches the condition.
func (r ApiGetRedfishV1SFSSAppEventsRequest) FilterCDCInstanceEq1(filterCDCInstanceEq1 string) ApiGetRedfishV1SFSSAppEventsRequest {
	r.filterCDCInstanceEq1 = &filterCDCInstanceEq1
	return r
}

func (r ApiGetRedfishV1SFSSAppEventsRequest) Execute() (*GetRedfishV1SFSSAppEvents200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppEventsExecute(r)
}

/*
GetRedfishV1SFSSAppEvents Get all events

This API retrieves a list of events from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppEventsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppEvents(ctx context.Context) ApiGetRedfishV1SFSSAppEventsRequest {
	return ApiGetRedfishV1SFSSAppEventsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppEvents200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppEventsExecute(r ApiGetRedfishV1SFSSAppEventsRequest) (*GetRedfishV1SFSSAppEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.top2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "?$top=2", r.top2, "form", "")
	}
	if r.filterCDCInstanceEq1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "?$filter=CDCInstance eq '1'", r.filterCDCInstanceEq1, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppEventsIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iD         string
}

func (r ApiGetRedfishV1SFSSAppEventsIDRequest) Execute() (*GetRedfishV1SFSSAppEventsID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppEventsIDExecute(r)
}

/*
GetRedfishV1SFSSAppEventsID Get specific event

This API retrieves detailed event information based on the specified event ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iD Event ID
	@return ApiGetRedfishV1SFSSAppEventsIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppEventsID(ctx context.Context, iD string) ApiGetRedfishV1SFSSAppEventsIDRequest {
	return ApiGetRedfishV1SFSSAppEventsIDRequest{
		ApiService: a,
		ctx:        ctx,
		iD:         iD,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppEventsID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppEventsIDExecute(r ApiGetRedfishV1SFSSAppEventsIDRequest) (*GetRedfishV1SFSSAppEventsID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppEventsID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppEventsID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Events({ID})"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iD) < 1 {
		return localVarReturnValue, nil, reportError("iD must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierRequest struct {
	ctx               context.Context
	ApiService        *DefaultAPIService
	instanceIdentifer string
}

func (r ApiGetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierRequest) Execute() (*GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierExecute(r)
}

/*
GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier Get specific foundational configuration

This API retrieves detailed foundational configuration information based on the specified instance identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param instanceIdentifer Instance identifier of the CDC
	@return ApiGetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier(ctx context.Context, instanceIdentifer string) ApiGetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierRequest {
	return ApiGetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierRequest{
		ApiService:        a,
		ctx:               ctx,
		instanceIdentifer: instanceIdentifer,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierExecute(r ApiGetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifierRequest) (*GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppFoundationalConfigsInstanceIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/FoundationalConfigs({InstanceIdentifer})"
	localVarPath = strings.Replace(localVarPath, "{"+"InstanceIdentifer"+"}", url.PathEscape(parameterValueToString(r.instanceIdentifer, "instanceIdentifer")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.instanceIdentifer) < 1 {
		return localVarReturnValue, nil, reportError("instanceIdentifer must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppGlobalSettingsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppGlobalSettingsRequest) Execute() (*GetRedfishV1SFSSAppGlobalSettings200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppGlobalSettingsExecute(r)
}

/*
GetRedfishV1SFSSAppGlobalSettings Get global settings

This API retrieves global settings configuration from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppGlobalSettingsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppGlobalSettings(ctx context.Context) ApiGetRedfishV1SFSSAppGlobalSettingsRequest {
	return ApiGetRedfishV1SFSSAppGlobalSettingsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppGlobalSettings200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppGlobalSettingsExecute(r ApiGetRedfishV1SFSSAppGlobalSettingsRequest) (*GetRedfishV1SFSSAppGlobalSettings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppGlobalSettings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppGlobalSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/GlobalSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppIpAddressManagementsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppIpAddressManagementsRequest) Execute() (*GetRedfishV1SFSSAppIpAddressManagements200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppIpAddressManagementsExecute(r)
}

/*
GetRedfishV1SFSSAppIpAddressManagements Get all interfaces

This API retrieves all the interfaces that are assigned an IP address in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppIpAddressManagementsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppIpAddressManagements(ctx context.Context) ApiGetRedfishV1SFSSAppIpAddressManagementsRequest {
	return ApiGetRedfishV1SFSSAppIpAddressManagementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppIpAddressManagements200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppIpAddressManagementsExecute(r ApiGetRedfishV1SFSSAppIpAddressManagementsRequest) (*GetRedfishV1SFSSAppIpAddressManagements200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppIpAddressManagements200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppIpAddressManagements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppIpAddressManagementsInterfaceRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	interface_ string
}

func (r ApiGetRedfishV1SFSSAppIpAddressManagementsInterfaceRequest) Execute() (*GetRedfishV1SFSSAppIpAddressManagementsInterface200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppIpAddressManagementsInterfaceExecute(r)
}

/*
GetRedfishV1SFSSAppIpAddressManagementsInterface Get specific interface

This API retrieves details of the specified interface from SFSS application based on the interface name. IPv4 and IPv6 route-specific configuration parameters are available from Release 1.3.0 onwards. See example-2 for sample route configuration in the response.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param interface_ Interface identifier
	@return ApiGetRedfishV1SFSSAppIpAddressManagementsInterfaceRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppIpAddressManagementsInterface(ctx context.Context, interface_ string) ApiGetRedfishV1SFSSAppIpAddressManagementsInterfaceRequest {
	return ApiGetRedfishV1SFSSAppIpAddressManagementsInterfaceRequest{
		ApiService: a,
		ctx:        ctx,
		interface_: interface_,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppIpAddressManagementsInterface200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppIpAddressManagementsInterfaceExecute(r ApiGetRedfishV1SFSSAppIpAddressManagementsInterfaceRequest) (*GetRedfishV1SFSSAppIpAddressManagementsInterface200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppIpAddressManagementsInterface200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppIpAddressManagementsInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements({interface})"
	localVarPath = strings.Replace(localVarPath, "{"+"interface"+"}", url.PathEscape(parameterValueToString(r.interface_, "interface_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppLicensesRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppLicensesRequest) Execute() (*GetRedfishV1SFSSAppLicenses200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppLicensesExecute(r)
}

/*
GetRedfishV1SFSSAppLicenses Get license count

This API retrieves information about the number of licenses installed in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppLicensesRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppLicenses(ctx context.Context) ApiGetRedfishV1SFSSAppLicensesRequest {
	return ApiGetRedfishV1SFSSAppLicensesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppLicenses200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppLicensesExecute(r ApiGetRedfishV1SFSSAppLicensesRequest) (*GetRedfishV1SFSSAppLicenses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppLicenses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppLicensesLicenseIdRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	licenseId  string
}

func (r ApiGetRedfishV1SFSSAppLicensesLicenseIdRequest) Execute() (*GetRedfishV1SFSSAppLicensesLicenseId200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppLicensesLicenseIdExecute(r)
}

/*
GetRedfishV1SFSSAppLicensesLicenseId Get specific license

This API retrieves details about the specified license based on the license identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param licenseId License identifier
	@return ApiGetRedfishV1SFSSAppLicensesLicenseIdRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppLicensesLicenseId(ctx context.Context, licenseId string) ApiGetRedfishV1SFSSAppLicensesLicenseIdRequest {
	return ApiGetRedfishV1SFSSAppLicensesLicenseIdRequest{
		ApiService: a,
		ctx:        ctx,
		licenseId:  licenseId,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppLicensesLicenseId200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppLicensesLicenseIdExecute(r ApiGetRedfishV1SFSSAppLicensesLicenseIdRequest) (*GetRedfishV1SFSSAppLicensesLicenseId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppLicensesLicenseId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppLicensesLicenseId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Licenses({LicenseId})"
	localVarPath = strings.Replace(localVarPath, "{"+"LicenseId"+"}", url.PathEscape(parameterValueToString(r.licenseId, "licenseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppLicensesexpandLicensesRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppLicensesexpandLicensesRequest) Execute() (*GetRedfishV1SFSSAppLicensesExpandLicenses200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppLicensesexpandLicensesExecute(r)
}

/*
GetRedfishV1SFSSAppLicensesexpandLicenses Get detailed license information

This API retrieves detailed license information from the system.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppLicensesexpandLicensesRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppLicensesexpandLicenses(ctx context.Context) ApiGetRedfishV1SFSSAppLicensesexpandLicensesRequest {
	return ApiGetRedfishV1SFSSAppLicensesexpandLicensesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppLicensesExpandLicenses200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppLicensesexpandLicensesExecute(r ApiGetRedfishV1SFSSAppLicensesexpandLicensesRequest) (*GetRedfishV1SFSSAppLicensesExpandLicenses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppLicensesExpandLicenses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppLicensesexpandLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Licenses?$expand=Licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppNTPRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppNTPRequest) Execute() (*GetRedfishV1SFSSAppNTP200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppNTPExecute(r)
}

/*
GetRedfishV1SFSSAppNTP Get NTP server information

This API configures an NTP server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppNTPRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppNTP(ctx context.Context) ApiGetRedfishV1SFSSAppNTPRequest {
	return ApiGetRedfishV1SFSSAppNTPRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppNTP200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppNTPExecute(r ApiGetRedfishV1SFSSAppNTPRequest) (*GetRedfishV1SFSSAppNTP200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppNTP200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppNTP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/NTP"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppRadiusServersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppRadiusServersRequest) Execute() (*GetRedfishV1SFSSAppRadiusServers200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppRadiusServersExecute(r)
}

/*
GetRedfishV1SFSSAppRadiusServers Get all RADIUS servers

This API retrieves a list of RADIUS servers configured in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppRadiusServersRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppRadiusServers(ctx context.Context) ApiGetRedfishV1SFSSAppRadiusServersRequest {
	return ApiGetRedfishV1SFSSAppRadiusServersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppRadiusServers200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppRadiusServersExecute(r ApiGetRedfishV1SFSSAppRadiusServersRequest) (*GetRedfishV1SFSSAppRadiusServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppRadiusServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppRadiusServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/RadiusServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppRadiusServersSequenceRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppRadiusServersSequenceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppRadiusServersSequenceExecute(r)
}

/*
GetRedfishV1SFSSAppRadiusServersSequence Get all RADIUS servers

This API retrieves a list of RADIUS servers that are configured in SFSS. This API returns the server IP addresses in the order in which they are configured.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppRadiusServersSequenceRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppRadiusServersSequence(ctx context.Context) ApiGetRedfishV1SFSSAppRadiusServersSequenceRequest {
	return ApiGetRedfishV1SFSSAppRadiusServersSequenceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetRedfishV1SFSSAppRadiusServersSequenceExecute(r ApiGetRedfishV1SFSSAppRadiusServersSequenceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppRadiusServersSequence")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/RadiusServers/Sequence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppRestoresRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppRestoresRequest) Execute() (*GetRedfishV1SFSSAppRestores200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppRestoresExecute(r)
}

/*
GetRedfishV1SFSSAppRestores Get all restores

This API retrieves all the available restore information from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppRestoresRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppRestores(ctx context.Context) ApiGetRedfishV1SFSSAppRestoresRequest {
	return ApiGetRedfishV1SFSSAppRestoresRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppRestores200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppRestoresExecute(r ApiGetRedfishV1SFSSAppRestoresRequest) (*GetRedfishV1SFSSAppRestores200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppRestores200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppRestores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Restores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppRestoresIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iD         string
}

func (r ApiGetRedfishV1SFSSAppRestoresIDRequest) Execute() (*GetRedfishV1SFSSAppRestoresID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppRestoresIDExecute(r)
}

/*
GetRedfishV1SFSSAppRestoresID Get specific restore

This API retrieves information about a restore operation based on the specified restore id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iD Restore identifier
	@return ApiGetRedfishV1SFSSAppRestoresIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppRestoresID(ctx context.Context, iD string) ApiGetRedfishV1SFSSAppRestoresIDRequest {
	return ApiGetRedfishV1SFSSAppRestoresIDRequest{
		ApiService: a,
		ctx:        ctx,
		iD:         iD,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppRestoresID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppRestoresIDExecute(r ApiGetRedfishV1SFSSAppRestoresIDRequest) (*GetRedfishV1SFSSAppRestoresID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppRestoresID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppRestoresID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Restores({ID})"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iD) < 1 {
		return localVarReturnValue, nil, reportError("iD must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppSFSSHealthStatusRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppSFSSHealthStatusRequest) Execute() (*GetRedfishV1SFSSAppSFSSHealthStatus200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppSFSSHealthStatusExecute(r)
}

/*
GetRedfishV1SFSSAppSFSSHealthStatus Get system health

This API retrieves SFSS system health status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppSFSSHealthStatusRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppSFSSHealthStatus(ctx context.Context) ApiGetRedfishV1SFSSAppSFSSHealthStatusRequest {
	return ApiGetRedfishV1SFSSAppSFSSHealthStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppSFSSHealthStatus200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppSFSSHealthStatusExecute(r ApiGetRedfishV1SFSSAppSFSSHealthStatusRequest) (*GetRedfishV1SFSSAppSFSSHealthStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppSFSSHealthStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppSFSSHealthStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSHealthStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppSosReportsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppSosReportsRequest) Execute() (*GetRedfishV1SFSSAppSosReports200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppSosReportsExecute(r)
}

/*
GetRedfishV1SFSSAppSosReports Get SOS report

This API retrieves the SOS report from SFSS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppSosReportsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppSosReports(ctx context.Context) ApiGetRedfishV1SFSSAppSosReportsRequest {
	return ApiGetRedfishV1SFSSAppSosReportsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppSosReports200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppSosReportsExecute(r ApiGetRedfishV1SFSSAppSosReportsRequest) (*GetRedfishV1SFSSAppSosReports200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppSosReports200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppSosReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SosReports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppSosReportsIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iD         string
}

func (r ApiGetRedfishV1SFSSAppSosReportsIDRequest) Execute() (*GetRedfishV1SFSSAppSosReportsID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppSosReportsIDExecute(r)
}

/*
GetRedfishV1SFSSAppSosReportsID Get specific SOS report

This API retrieves details about the SOS report based on the specified SOS report ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iD SOS report ID
	@return ApiGetRedfishV1SFSSAppSosReportsIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppSosReportsID(ctx context.Context, iD string) ApiGetRedfishV1SFSSAppSosReportsIDRequest {
	return ApiGetRedfishV1SFSSAppSosReportsIDRequest{
		ApiService: a,
		ctx:        ctx,
		iD:         iD,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppSosReportsID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppSosReportsIDExecute(r ApiGetRedfishV1SFSSAppSosReportsIDRequest) (*GetRedfishV1SFSSAppSosReportsID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppSosReportsID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppSosReportsID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SosReports({ID})"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iD) < 1 {
		return localVarReturnValue, nil, reportError("iD must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppSosReportsexpandSosReportsRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppSosReportsexpandSosReportsRequest) Execute() (*GetRedfishV1SFSSAppSosReportsExpandSosReports200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppSosReportsexpandSosReportsExecute(r)
}

/*
GetRedfishV1SFSSAppSosReportsexpandSosReports Get all SOS reports

This API retrieves details about all the available SOS reports from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppSosReportsexpandSosReportsRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppSosReportsexpandSosReports(ctx context.Context) ApiGetRedfishV1SFSSAppSosReportsexpandSosReportsRequest {
	return ApiGetRedfishV1SFSSAppSosReportsexpandSosReportsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppSosReportsExpandSosReports200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppSosReportsexpandSosReportsExecute(r ApiGetRedfishV1SFSSAppSosReportsexpandSosReportsRequest) (*GetRedfishV1SFSSAppSosReportsExpandSosReports200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppSosReportsExpandSosReports200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppSosReportsexpandSosReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SosReports?$expand=SosReports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppTacacsServersRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppTacacsServersRequest) Execute() (*GetRedfishV1SFSSAppTacacsServers200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppTacacsServersExecute(r)
}

/*
GetRedfishV1SFSSAppTacacsServers Get all TACACS+ servers

This API retrieves TACACS+ server information configured in the SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppTacacsServersRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppTacacsServers(ctx context.Context) ApiGetRedfishV1SFSSAppTacacsServersRequest {
	return ApiGetRedfishV1SFSSAppTacacsServersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppTacacsServers200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppTacacsServersExecute(r ApiGetRedfishV1SFSSAppTacacsServersRequest) (*GetRedfishV1SFSSAppTacacsServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppTacacsServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppTacacsServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/TacacsServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppTacacsServersSequenceRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppTacacsServersSequenceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppTacacsServersSequenceExecute(r)
}

/*
GetRedfishV1SFSSAppTacacsServersSequence Get all TACACS+ servers

This API retrieves a list of TACACS+ servers that are configured in SFSS. This API returns the server IP addresses in the order in which they are configured.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppTacacsServersSequenceRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppTacacsServersSequence(ctx context.Context) ApiGetRedfishV1SFSSAppTacacsServersSequenceRequest {
	return ApiGetRedfishV1SFSSAppTacacsServersSequenceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) GetRedfishV1SFSSAppTacacsServersSequenceExecute(r ApiGetRedfishV1SFSSAppTacacsServersSequenceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppTacacsServersSequence")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/TacacsServers/Sequence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppUserActivityAuditRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSAppUserActivityAuditRequest) Execute() (*GetRedfishV1SFSSAppUserActivityAudit200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppUserActivityAuditExecute(r)
}

/*
GetRedfishV1SFSSAppUserActivityAudit Get user activities

This API retrieves user activity details from SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSAppUserActivityAuditRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppUserActivityAudit(ctx context.Context) ApiGetRedfishV1SFSSAppUserActivityAuditRequest {
	return ApiGetRedfishV1SFSSAppUserActivityAuditRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppUserActivityAudit200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppUserActivityAuditExecute(r ApiGetRedfishV1SFSSAppUserActivityAuditRequest) (*GetRedfishV1SFSSAppUserActivityAudit200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppUserActivityAudit200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppUserActivityAudit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/UserActivityAudit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSAppUserActivityAuditIDRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	iD         string
}

func (r ApiGetRedfishV1SFSSAppUserActivityAuditIDRequest) Execute() (*GetRedfishV1SFSSAppUserActivityAuditID200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSAppUserActivityAuditIDExecute(r)
}

/*
GetRedfishV1SFSSAppUserActivityAuditID Get specific user activity

This API retrieves detailed user activity information based on the specified audit identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param iD User activity audit identifier
	@return ApiGetRedfishV1SFSSAppUserActivityAuditIDRequest
*/
func (a *DefaultAPIService) GetRedfishV1SFSSAppUserActivityAuditID(ctx context.Context, iD string) ApiGetRedfishV1SFSSAppUserActivityAuditIDRequest {
	return ApiGetRedfishV1SFSSAppUserActivityAuditIDRequest{
		ApiService: a,
		ctx:        ctx,
		iD:         iD,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSAppUserActivityAuditID200Response
func (a *DefaultAPIService) GetRedfishV1SFSSAppUserActivityAuditIDExecute(r ApiGetRedfishV1SFSSAppUserActivityAuditIDRequest) (*GetRedfishV1SFSSAppUserActivityAuditID200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSAppUserActivityAuditID200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSAppUserActivityAuditID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/UserActivityAudit({ID})"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", url.PathEscape(parameterValueToString(r.iD, "iD")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.iD) < 1 {
		return localVarReturnValue, nil, reportError("iD must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRedfishV1SFSSApp_0Request struct {
	ctx        context.Context
	ApiService *DefaultAPIService
}

func (r ApiGetRedfishV1SFSSApp_0Request) Execute() (*GetRedfishV1SFSSApp200Response, *http.Response, error) {
	return r.ApiService.GetRedfishV1SFSSApp_1Execute(r)
}

/*
GetRedfishV1SFSSApp_0 Get all images

This API retrieves all the SFSS images available in the system.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRedfishV1SFSSApp_0Request
*/
func (a *DefaultAPIService) GetRedfishV1SFSSApp_1(ctx context.Context) ApiGetRedfishV1SFSSApp_0Request {
	return ApiGetRedfishV1SFSSApp_0Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetRedfishV1SFSSApp200Response
func (a *DefaultAPIService) GetRedfishV1SFSSApp_1Execute(r ApiGetRedfishV1SFSSApp_0Request) (*GetRedfishV1SFSSApp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetRedfishV1SFSSApp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetRedfishV1SFSSApp_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSImages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTRedfishV1SFSSAppRequest struct {
	ctx                        context.Context
	ApiService                 *DefaultAPIService
	pUTRedfishV1SFSSAppRequest *PUTRedfishV1SFSSAppRequest
}

// {     \&quot;Version\&quot;: \&quot;1.2.0\&quot; }
func (r ApiPUTRedfishV1SFSSAppRequest) PUTRedfishV1SFSSAppRequest(pUTRedfishV1SFSSAppRequest PUTRedfishV1SFSSAppRequest) ApiPUTRedfishV1SFSSAppRequest {
	r.pUTRedfishV1SFSSAppRequest = &pUTRedfishV1SFSSAppRequest
	return r
}

func (r ApiPUTRedfishV1SFSSAppRequest) Execute() (*PUTRedfishV1SFSSAppRequest, *http.Response, error) {
	return r.ApiService.PUTRedfishV1SFSSAppExecute(r)
}

/*
PUTRedfishV1SFSSApp Upgrade SFSS application

This API upgrades the SFSS application to the specified version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPUTRedfishV1SFSSAppRequest
*/
func (a *DefaultAPIService) PUTRedfishV1SFSSApp(ctx context.Context) ApiPUTRedfishV1SFSSAppRequest {
	return ApiPUTRedfishV1SFSSAppRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PUTRedfishV1SFSSAppRequest
func (a *DefaultAPIService) PUTRedfishV1SFSSAppExecute(r ApiPUTRedfishV1SFSSAppRequest) (*PUTRedfishV1SFSSAppRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PUTRedfishV1SFSSAppRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PUTRedfishV1SFSSApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pUTRedfishV1SFSSAppRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTRedfishV1SFSSAppLicensesRequest struct {
	ctx                                context.Context
	ApiService                         *DefaultAPIService
	pUTRedfishV1SFSSAppLicensesRequest *PUTRedfishV1SFSSAppLicensesRequest
}

// { \&quot;Identifier\&quot;: \&quot;2\&quot;, \&quot;EULA\&quot;: \&quot;Agreed\&quot; }
func (r ApiPUTRedfishV1SFSSAppLicensesRequest) PUTRedfishV1SFSSAppLicensesRequest(pUTRedfishV1SFSSAppLicensesRequest PUTRedfishV1SFSSAppLicensesRequest) ApiPUTRedfishV1SFSSAppLicensesRequest {
	r.pUTRedfishV1SFSSAppLicensesRequest = &pUTRedfishV1SFSSAppLicensesRequest
	return r
}

func (r ApiPUTRedfishV1SFSSAppLicensesRequest) Execute() (*PUTRedfishV1SFSSAppLicenses200Response, *http.Response, error) {
	return r.ApiService.PUTRedfishV1SFSSAppLicensesExecute(r)
}

/*
PUTRedfishV1SFSSAppLicenses Accept EULA

This API is used to accept the End User License Agreement (EULA) for the partner license.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPUTRedfishV1SFSSAppLicensesRequest
*/
func (a *DefaultAPIService) PUTRedfishV1SFSSAppLicenses(ctx context.Context) ApiPUTRedfishV1SFSSAppLicensesRequest {
	return ApiPUTRedfishV1SFSSAppLicensesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PUTRedfishV1SFSSAppLicenses200Response
func (a *DefaultAPIService) PUTRedfishV1SFSSAppLicensesExecute(r ApiPUTRedfishV1SFSSAppLicensesRequest) (*PUTRedfishV1SFSSAppLicenses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PUTRedfishV1SFSSAppLicenses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PUTRedfishV1SFSSAppLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pUTRedfishV1SFSSAppLicensesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppAlertsRequest struct {
	ctx                               context.Context
	ApiService                        *DefaultAPIService
	postRedfishV1SFSSAppAlertsRequest *PostRedfishV1SFSSAppAlertsRequest
}

// {     \&quot;Protocol\&quot;: \&quot;redfish\&quot;,     \&quot;Context\&quot;: \&quot;SomeSubscription\&quot;,     \&quot;EventTypes\&quot;: [          \&quot;Alert\&quot;      ],     \&quot;CdcInstances\&quot;: [         \&quot;APP\&quot;     ],     \&quot;HttpHeaders\&quot;: [         \&quot;Authorization: Basic ZG52dXNlcjpAIThwSU1vSQ&#x3D;&#x3D;\&quot;,         \&quot;ExternalServerRequiredHeader: ItsValue\&quot;     ],     \&quot;Destination\&quot;: \&quot;https://[ipv4/ipv6]/external/Server/eventHandler\&quot;  }
func (r ApiPostRedfishV1SFSSAppAlertsRequest) PostRedfishV1SFSSAppAlertsRequest(postRedfishV1SFSSAppAlertsRequest PostRedfishV1SFSSAppAlertsRequest) ApiPostRedfishV1SFSSAppAlertsRequest {
	r.postRedfishV1SFSSAppAlertsRequest = &postRedfishV1SFSSAppAlertsRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppAlertsRequest) Execute() (*PostRedfishV1SFSSAppAlerts200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppAlertsExecute(r)
}

/*
PostRedfishV1SFSSAppAlerts Add alert

This API creates an alert in the SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppAlertsRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppAlerts(ctx context.Context) ApiPostRedfishV1SFSSAppAlertsRequest {
	return ApiPostRedfishV1SFSSAppAlertsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppAlerts200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppAlertsExecute(r ApiPostRedfishV1SFSSAppAlertsRequest) (*PostRedfishV1SFSSAppAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppAlertsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest struct {
	ctx                                               context.Context
	ApiService                                        *DefaultAPIService
	postRedfishV1SFSSAppAuthenticationSequenceRequest *PostRedfishV1SFSSAppAuthenticationSequenceRequest
}

// {  \&quot;AuthenticationSequence\&quot;: [         \&quot;tacacs+\&quot;,         \&quot;local\&quot;     ]  }
func (r ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest) PostRedfishV1SFSSAppAuthenticationSequenceRequest(postRedfishV1SFSSAppAuthenticationSequenceRequest PostRedfishV1SFSSAppAuthenticationSequenceRequest) ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest {
	r.postRedfishV1SFSSAppAuthenticationSequenceRequest = &postRedfishV1SFSSAppAuthenticationSequenceRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest) Execute() (*PostRedfishV1SFSSAppAuthenticationSequence200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppAuthenticationSequenceExecute(r)
}

/*
PostRedfishV1SFSSAppAuthenticationSequence Add authentication sequence

This API creates an authentication sequence in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppAuthenticationSequence(ctx context.Context) ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest {
	return ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppAuthenticationSequence200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppAuthenticationSequenceExecute(r ApiPostRedfishV1SFSSAppAuthenticationSequenceRequest) (*PostRedfishV1SFSSAppAuthenticationSequence200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppAuthenticationSequence200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppAuthenticationSequence")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/AuthenticationSequence"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppAuthenticationSequenceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppBackupsRequest struct {
	ctx                                context.Context
	ApiService                         *DefaultAPIService
	postRedfishV1SFSSAppBackupsRequest *PostRedfishV1SFSSAppBackupsRequest
}

// {             \&quot;ImageServerLocation\&quot;: \&quot;100.94.72.166:/home/dell/temp_images/\&quot;,             \&quot;ImageServerPassword\&quot;: \&quot;Force10\&quot;,             \&quot;TransportType\&quot;: \&quot;SCP\&quot;,             \&quot;ImageServerUserName\&quot;: \&quot;Dell\&quot;         }
func (r ApiPostRedfishV1SFSSAppBackupsRequest) PostRedfishV1SFSSAppBackupsRequest(postRedfishV1SFSSAppBackupsRequest PostRedfishV1SFSSAppBackupsRequest) ApiPostRedfishV1SFSSAppBackupsRequest {
	r.postRedfishV1SFSSAppBackupsRequest = &postRedfishV1SFSSAppBackupsRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppBackupsRequest) Execute() (*PostRedfishV1SFSSAppBackups200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppBackupsExecute(r)
}

/*
PostRedfishV1SFSSAppBackups Perform backup

This API creates a backup of the SFSS configuration data in the specified server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppBackupsRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppBackups(ctx context.Context) ApiPostRedfishV1SFSSAppBackupsRequest {
	return ApiPostRedfishV1SFSSAppBackupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppBackups200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppBackupsExecute(r ApiPostRedfishV1SFSSAppBackupsRequest) (*PostRedfishV1SFSSAppBackups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppBackups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppBackups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Backups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppBackupsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppChangePasswordRequest struct {
	ctx                                       context.Context
	ApiService                                *DefaultAPIService
	postRedfishV1SFSSAppChangePasswordRequest *PostRedfishV1SFSSAppChangePasswordRequest
}

// { \&quot;OldPassword\&quot;:\&quot;admin\&quot;, \&quot;NewPassword\&quot; : \&quot;Xskfdj@fdk10\&quot; }
func (r ApiPostRedfishV1SFSSAppChangePasswordRequest) PostRedfishV1SFSSAppChangePasswordRequest(postRedfishV1SFSSAppChangePasswordRequest PostRedfishV1SFSSAppChangePasswordRequest) ApiPostRedfishV1SFSSAppChangePasswordRequest {
	r.postRedfishV1SFSSAppChangePasswordRequest = &postRedfishV1SFSSAppChangePasswordRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppChangePasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppChangePasswordExecute(r)
}

/*
PostRedfishV1SFSSAppChangePassword Change admin password

This API allows the user to change the admin user password.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppChangePasswordRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppChangePassword(ctx context.Context) ApiPostRedfishV1SFSSAppChangePasswordRequest {
	return ApiPostRedfishV1SFSSAppChangePasswordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PostRedfishV1SFSSAppChangePasswordExecute(r ApiPostRedfishV1SFSSAppChangePasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppChangePassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/ChangePassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppChangePasswordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest struct {
	ctx                                              context.Context
	ApiService                                       *DefaultAPIService
	postRedfishV1SFSSAppFabricManagerInfoPostRequest *PostRedfishV1SFSSAppFabricManagerInfoPostRequest
}

// {     \&quot;InstanceIdentifier\&quot;: \&quot;1\&quot;,     \&quot;Interfaces\&quot;: [\&quot;ens192\&quot;],     \&quot;CDCAdminState\&quot;:\&quot;Enable\&quot;,     \&quot;DiscoverySvcAdminState\&quot;:\&quot;Enable\&quot; }
func (r ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest) PostRedfishV1SFSSAppFabricManagerInfoPostRequest(postRedfishV1SFSSAppFabricManagerInfoPostRequest PostRedfishV1SFSSAppFabricManagerInfoPostRequest) ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest {
	r.postRedfishV1SFSSAppFabricManagerInfoPostRequest = &postRedfishV1SFSSAppFabricManagerInfoPostRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest) Execute() (*PostRedfishV1SFSSAppFabricManagerInfoPost200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppFabricManagerInfoPostExecute(r)
}

/*
PostRedfishV1SFSSAppFabricManagerInfoPost Configure CDC instance

This API creates a CDC instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppFabricManagerInfoPost(ctx context.Context) ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest {
	return ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppFabricManagerInfoPost200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppFabricManagerInfoPostExecute(r ApiPostRedfishV1SFSSAppFabricManagerInfoPostRequest) (*PostRedfishV1SFSSAppFabricManagerInfoPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppFabricManagerInfoPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppFabricManagerInfoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCInstanceManagers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppFabricManagerInfoPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppGlobalSettingsRequest struct {
	ctx                                       context.Context
	ApiService                                *DefaultAPIService
	postRedfishV1SFSSAppGlobalSettingsRequest *PostRedfishV1SFSSAppGlobalSettingsRequest
}

// {     \&quot;HostName\&quot;: \&quot;dellemc-networkappliance\&quot;,     \&quot;ReservedIPV4SubnetPrefix\&quot;: \&quot;172.20\&quot;,     \&quot;ReservedIPV6SubnetPrefix\&quot;: \&quot;fd02\&quot;,     \&quot;StorageInterfaceMTU\&quot;: 7000  }
func (r ApiPostRedfishV1SFSSAppGlobalSettingsRequest) PostRedfishV1SFSSAppGlobalSettingsRequest(postRedfishV1SFSSAppGlobalSettingsRequest PostRedfishV1SFSSAppGlobalSettingsRequest) ApiPostRedfishV1SFSSAppGlobalSettingsRequest {
	r.postRedfishV1SFSSAppGlobalSettingsRequest = &postRedfishV1SFSSAppGlobalSettingsRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppGlobalSettingsExecute(r)
}

/*
PostRedfishV1SFSSAppGlobalSettings Configure global settings

This API configures global settings in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppGlobalSettingsRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppGlobalSettings(ctx context.Context) ApiPostRedfishV1SFSSAppGlobalSettingsRequest {
	return ApiPostRedfishV1SFSSAppGlobalSettingsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PostRedfishV1SFSSAppGlobalSettingsExecute(r ApiPostRedfishV1SFSSAppGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/GlobalSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppGlobalSettingsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppIpAddressManagementsRequest struct {
	ctx                                             context.Context
	ApiService                                      *DefaultAPIService
	postRedfishV1SFSSAppIpAddressManagementsRequest *PostRedfishV1SFSSAppIpAddressManagementsRequest
}

func (r ApiPostRedfishV1SFSSAppIpAddressManagementsRequest) PostRedfishV1SFSSAppIpAddressManagementsRequest(postRedfishV1SFSSAppIpAddressManagementsRequest PostRedfishV1SFSSAppIpAddressManagementsRequest) ApiPostRedfishV1SFSSAppIpAddressManagementsRequest {
	r.postRedfishV1SFSSAppIpAddressManagementsRequest = &postRedfishV1SFSSAppIpAddressManagementsRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppIpAddressManagementsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppIpAddressManagementsExecute(r)
}

/*
PostRedfishV1SFSSAppIpAddressManagements Configure interface

This API configures an interface in SFSS application and assigns the specified IP address to the interface. IPv4 and IPv6 route-specific configuration parameters are available from Release 1.3.0 onwards. See example-2 with route configuration for payload details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppIpAddressManagementsRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppIpAddressManagements(ctx context.Context) ApiPostRedfishV1SFSSAppIpAddressManagementsRequest {
	return ApiPostRedfishV1SFSSAppIpAddressManagementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PostRedfishV1SFSSAppIpAddressManagementsExecute(r ApiPostRedfishV1SFSSAppIpAddressManagementsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppIpAddressManagements")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppIpAddressManagementsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppLicensesRequest struct {
	ctx                                 context.Context
	ApiService                          *DefaultAPIService
	postRedfishV1SFSSAppLicensesRequest *PostRedfishV1SFSSAppLicensesRequest
}

// {    \&quot;LicenseContent\&quot; :\&quot;Actual XML-LicenseContent\&quot;,     \&quot;LicenseFileName\&quot;: \&quot;BaseLicense.lic\&quot;  }
func (r ApiPostRedfishV1SFSSAppLicensesRequest) PostRedfishV1SFSSAppLicensesRequest(postRedfishV1SFSSAppLicensesRequest PostRedfishV1SFSSAppLicensesRequest) ApiPostRedfishV1SFSSAppLicensesRequest {
	r.postRedfishV1SFSSAppLicensesRequest = &postRedfishV1SFSSAppLicensesRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppLicensesRequest) Execute() (*PostRedfishV1SFSSAppLicenses200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppLicensesExecute(r)
}

/*
PostRedfishV1SFSSAppLicenses Install a license

This API installs a license in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppLicensesRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppLicenses(ctx context.Context) ApiPostRedfishV1SFSSAppLicensesRequest {
	return ApiPostRedfishV1SFSSAppLicensesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppLicenses200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppLicensesExecute(r ApiPostRedfishV1SFSSAppLicensesRequest) (*PostRedfishV1SFSSAppLicenses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppLicenses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppLicensesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppNTP1Request struct {
	ctx                             context.Context
	ApiService                      *DefaultAPIService
	postRedfishV1SFSSAppNTP1Request *PostRedfishV1SFSSAppNTP1Request
}

func (r ApiPostRedfishV1SFSSAppNTP1Request) PostRedfishV1SFSSAppNTP1Request(postRedfishV1SFSSAppNTP1Request PostRedfishV1SFSSAppNTP1Request) ApiPostRedfishV1SFSSAppNTP1Request {
	r.postRedfishV1SFSSAppNTP1Request = &postRedfishV1SFSSAppNTP1Request
	return r
}

func (r ApiPostRedfishV1SFSSAppNTP1Request) Execute() (*PostRedfishV1SFSSAppNTP1200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppNTP1Execute(r)
}

/*
PostRedfishV1SFSSAppNTP1 Configure NTP server

This API restores an SFSS configuration from the backup file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppNTP1Request
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppNTP1(ctx context.Context) ApiPostRedfishV1SFSSAppNTP1Request {
	return ApiPostRedfishV1SFSSAppNTP1Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppNTP1200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppNTP1Execute(r ApiPostRedfishV1SFSSAppNTP1Request) (*PostRedfishV1SFSSAppNTP1200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppNTP1200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppNTP1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/NTP"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppNTP1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppRadiusServersRequest struct {
	ctx                                      context.Context
	ApiService                               *DefaultAPIService
	postRedfishV1SFSSAppRadiusServersRequest *PostRedfishV1SFSSAppRadiusServersRequest
}

// {  \&quot;ServerIp\&quot;: \&quot;200.1.1.1\&quot;, \&quot;ServerPass\&quot;: \&quot;xxxxxx\&quot;  }
func (r ApiPostRedfishV1SFSSAppRadiusServersRequest) PostRedfishV1SFSSAppRadiusServersRequest(postRedfishV1SFSSAppRadiusServersRequest PostRedfishV1SFSSAppRadiusServersRequest) ApiPostRedfishV1SFSSAppRadiusServersRequest {
	r.postRedfishV1SFSSAppRadiusServersRequest = &postRedfishV1SFSSAppRadiusServersRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppRadiusServersRequest) Execute() (*PostRedfishV1SFSSAppRadiusServers200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppRadiusServersExecute(r)
}

/*
PostRedfishV1SFSSAppRadiusServers Configure RADIUS server

This API configures a RADIUS server for authentication in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppRadiusServersRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppRadiusServers(ctx context.Context) ApiPostRedfishV1SFSSAppRadiusServersRequest {
	return ApiPostRedfishV1SFSSAppRadiusServersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppRadiusServers200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppRadiusServersExecute(r ApiPostRedfishV1SFSSAppRadiusServersRequest) (*PostRedfishV1SFSSAppRadiusServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppRadiusServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppRadiusServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/RadiusServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppRadiusServersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppRestoresRequest struct {
	ctx                                 context.Context
	ApiService                          *DefaultAPIService
	postRedfishV1SFSSAppRestoresRequest *PostRedfishV1SFSSAppRestoresRequest
}

// {             \&quot;ImageServerLocation\&quot;: \&quot;100.94.72.166:/home/dell/temp_images/backup_file.tar.gz\&quot;,             \&quot;ImageServerPassword\&quot;: \&quot;Force10\&quot;,             \&quot;TransportType\&quot;: \&quot;SCP\&quot;,             \&quot;ImageServerUserName\&quot;: \&quot;Dell\&quot;         }
func (r ApiPostRedfishV1SFSSAppRestoresRequest) PostRedfishV1SFSSAppRestoresRequest(postRedfishV1SFSSAppRestoresRequest PostRedfishV1SFSSAppRestoresRequest) ApiPostRedfishV1SFSSAppRestoresRequest {
	r.postRedfishV1SFSSAppRestoresRequest = &postRedfishV1SFSSAppRestoresRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppRestoresRequest) Execute() (*PostRedfishV1SFSSAppRestores200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppRestoresExecute(r)
}

/*
PostRedfishV1SFSSAppRestores Restore a backup

This API restores an SFSS configuration from the backup file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppRestoresRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppRestores(ctx context.Context) ApiPostRedfishV1SFSSAppRestoresRequest {
	return ApiPostRedfishV1SFSSAppRestoresRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppRestores200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppRestoresExecute(r ApiPostRedfishV1SFSSAppRestoresRequest) (*PostRedfishV1SFSSAppRestores200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppRestores200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppRestores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Restores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppRestoresRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppSFSSImagesRequest struct {
	ctx                                   context.Context
	ApiService                            *DefaultAPIService
	postRedfishV1SFSSAppSFSSImagesRequest *PostRedfishV1SFSSAppSFSSImagesRequest
}

func (r ApiPostRedfishV1SFSSAppSFSSImagesRequest) PostRedfishV1SFSSAppSFSSImagesRequest(postRedfishV1SFSSAppSFSSImagesRequest PostRedfishV1SFSSAppSFSSImagesRequest) ApiPostRedfishV1SFSSAppSFSSImagesRequest {
	r.postRedfishV1SFSSAppSFSSImagesRequest = &postRedfishV1SFSSAppSFSSImagesRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppSFSSImagesRequest) Execute() (*PutRedfishV1SFSSApp200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppSFSSImagesExecute(r)
}

/*
PostRedfishV1SFSSAppSFSSImages Add image

This API adds an SFSS image to the SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppSFSSImagesRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppSFSSImages(ctx context.Context) ApiPostRedfishV1SFSSAppSFSSImagesRequest {
	return ApiPostRedfishV1SFSSAppSFSSImagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PutRedfishV1SFSSApp200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppSFSSImagesExecute(r ApiPostRedfishV1SFSSAppSFSSImagesRequest) (*PutRedfishV1SFSSApp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutRedfishV1SFSSApp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppSFSSImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSImages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppSFSSImagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRedfishV1SFSSAppTacacsServersRequest struct {
	ctx                                      context.Context
	ApiService                               *DefaultAPIService
	postRedfishV1SFSSAppTacacsServersRequest *PostRedfishV1SFSSAppTacacsServersRequest
}

// {  \&quot;ServerIp\&quot;: \&quot;200.1.1.1\&quot;, \&quot;ServerPass\&quot;: \&quot;xxxxxx\&quot;  }
func (r ApiPostRedfishV1SFSSAppTacacsServersRequest) PostRedfishV1SFSSAppTacacsServersRequest(postRedfishV1SFSSAppTacacsServersRequest PostRedfishV1SFSSAppTacacsServersRequest) ApiPostRedfishV1SFSSAppTacacsServersRequest {
	r.postRedfishV1SFSSAppTacacsServersRequest = &postRedfishV1SFSSAppTacacsServersRequest
	return r
}

func (r ApiPostRedfishV1SFSSAppTacacsServersRequest) Execute() (*PostRedfishV1SFSSAppTacacsServers200Response, *http.Response, error) {
	return r.ApiService.PostRedfishV1SFSSAppTacacsServersExecute(r)
}

/*
PostRedfishV1SFSSAppTacacsServers Configure TACACS+ server

This API configures a TACACS+ server in SFSS application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRedfishV1SFSSAppTacacsServersRequest
*/
func (a *DefaultAPIService) PostRedfishV1SFSSAppTacacsServers(ctx context.Context) ApiPostRedfishV1SFSSAppTacacsServersRequest {
	return ApiPostRedfishV1SFSSAppTacacsServersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppTacacsServers200Response
func (a *DefaultAPIService) PostRedfishV1SFSSAppTacacsServersExecute(r ApiPostRedfishV1SFSSAppTacacsServersRequest) (*PostRedfishV1SFSSAppTacacsServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppTacacsServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRedfishV1SFSSAppTacacsServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/TacacsServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRedfishV1SFSSAppTacacsServersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRedfishV1SFSSAppRequest struct {
	ctx                        context.Context
	ApiService                 *DefaultAPIService
	versiontbd                 *string
	putRedfishV1SFSSAppRequest *PutRedfishV1SFSSAppRequest
}

// ImageId
func (r ApiPutRedfishV1SFSSAppRequest) Versiontbd(versiontbd string) ApiPutRedfishV1SFSSAppRequest {
	r.versiontbd = &versiontbd
	return r
}

// {     \&quot;ImageServerUserName\&quot; : \&quot;dell\&quot;,     \&quot;ImageServerPassword\&quot; : \&quot;New_Password\&quot;,     \&quot;ImageServerLocation\&quot; : \&quot;100.94.72.166:/home/dell/new_location/SFSS-1.2.0.deb\&quot;,     \&quot;TransportType\&quot; : \&quot;SCP\&quot; }
func (r ApiPutRedfishV1SFSSAppRequest) PutRedfishV1SFSSAppRequest(putRedfishV1SFSSAppRequest PutRedfishV1SFSSAppRequest) ApiPutRedfishV1SFSSAppRequest {
	r.putRedfishV1SFSSAppRequest = &putRedfishV1SFSSAppRequest
	return r
}

func (r ApiPutRedfishV1SFSSAppRequest) Execute() (*PutRedfishV1SFSSApp200Response, *http.Response, error) {
	return r.ApiService.PutRedfishV1SFSSAppExecute(r)
}

/*
PutRedfishV1SFSSApp Upgrade application

This API upgrades the SFSS application to the specified version from the list of available images.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutRedfishV1SFSSAppRequest
*/
func (a *DefaultAPIService) PutRedfishV1SFSSApp(ctx context.Context) ApiPutRedfishV1SFSSAppRequest {
	return ApiPutRedfishV1SFSSAppRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PutRedfishV1SFSSApp200Response
func (a *DefaultAPIService) PutRedfishV1SFSSAppExecute(r ApiPutRedfishV1SFSSAppRequest) (*PutRedfishV1SFSSApp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutRedfishV1SFSSApp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutRedfishV1SFSSApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/SFSSImages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.versiontbd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versiontbd", r.versiontbd, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putRedfishV1SFSSAppRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRedfishV1SFSSAppAlertsRequest struct {
	ctx                              context.Context
	ApiService                       *DefaultAPIService
	uuid                             string
	putRedfishV1SFSSAppAlertsRequest *PutRedfishV1SFSSAppAlertsRequest
}

// {     \&quot;Protocol\&quot;: \&quot;redfish\&quot;,      \&quot;Identifier\&quot;: \&quot;uuid\&quot;,      \&quot;Context\&quot;: \&quot;NewSubscription\&quot;,     \&quot;EventTypes\&quot;: [          \&quot;Alert\&quot;      ],    \&quot;CdcInstances\&quot;: [         \&quot;APP\&quot;     ],      \&quot;HttpHeaders\&quot;: [         \&quot;Authorization: Basic ZZZZZZZZZZZZZZZZZZZZZZZZZZ\&quot;,         \&quot;ExternalServerRequiredHeader: ItsValue\&quot;     ],     \&quot;Destination\&quot;: \&quot;https://[ipv4/ipv6]/external/Server/NeweventHandler\&quot;  }
func (r ApiPutRedfishV1SFSSAppAlertsRequest) PutRedfishV1SFSSAppAlertsRequest(putRedfishV1SFSSAppAlertsRequest PutRedfishV1SFSSAppAlertsRequest) ApiPutRedfishV1SFSSAppAlertsRequest {
	r.putRedfishV1SFSSAppAlertsRequest = &putRedfishV1SFSSAppAlertsRequest
	return r
}

func (r ApiPutRedfishV1SFSSAppAlertsRequest) Execute() (*PostRedfishV1SFSSAppAlerts200Response, *http.Response, error) {
	return r.ApiService.PutRedfishV1SFSSAppAlertsExecute(r)
}

/*
PutRedfishV1SFSSAppAlerts Update alert

This API updates an existing alert in the SFSS application based on the alert identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid Alert UUID
	@return ApiPutRedfishV1SFSSAppAlertsRequest
*/
func (a *DefaultAPIService) PutRedfishV1SFSSAppAlerts(ctx context.Context, uuid string) ApiPutRedfishV1SFSSAppAlertsRequest {
	return ApiPutRedfishV1SFSSAppAlertsRequest{
		ApiService: a,
		ctx:        ctx,
		uuid:       uuid,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppAlerts200Response
func (a *DefaultAPIService) PutRedfishV1SFSSAppAlertsExecute(r ApiPutRedfishV1SFSSAppAlertsRequest) (*PostRedfishV1SFSSAppAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutRedfishV1SFSSAppAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/Alerts({uuid})"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putRedfishV1SFSSAppAlertsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest struct {
	ctx                                           context.Context
	ApiService                                    *DefaultAPIService
	instanceId                                    string
	putRedfishV1SFSSAppCDCInstanceManagersRequest *PutRedfishV1SFSSAppCDCInstanceManagersRequest
}

// {     \&quot;InstanceIdentifier\&quot;: \&quot;1\&quot;,     \&quot;Interfaces\&quot;: [\&quot;ens192\&quot;],     \&quot;CDCAdminState\&quot;:\&quot;Enable\&quot;,     \&quot;DiscoverySvcAdminState\&quot;:\&quot;Disable\&quot; }
func (r ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest) PutRedfishV1SFSSAppCDCInstanceManagersRequest(putRedfishV1SFSSAppCDCInstanceManagersRequest PutRedfishV1SFSSAppCDCInstanceManagersRequest) ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest {
	r.putRedfishV1SFSSAppCDCInstanceManagersRequest = &putRedfishV1SFSSAppCDCInstanceManagersRequest
	return r
}

func (r ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest) Execute() (*PostRedfishV1SFSSAppFabricManagerInfoPost200Response, *http.Response, error) {
	return r.ApiService.PutRedfishV1SFSSAppCDCInstanceManagersExecute(r)
}

/*
PutRedfishV1SFSSAppCDCInstanceManagers Update CDC instance

This API updates CDC instance information based on the specified instance identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param instanceId InstanceIdentifier
	@return ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest
*/
func (a *DefaultAPIService) PutRedfishV1SFSSAppCDCInstanceManagers(ctx context.Context, instanceId string) ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest {
	return ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest{
		ApiService: a,
		ctx:        ctx,
		instanceId: instanceId,
	}
}

// Execute executes the request
//
//	@return PostRedfishV1SFSSAppFabricManagerInfoPost200Response
func (a *DefaultAPIService) PutRedfishV1SFSSAppCDCInstanceManagersExecute(r ApiPutRedfishV1SFSSAppCDCInstanceManagersRequest) (*PostRedfishV1SFSSAppFabricManagerInfoPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostRedfishV1SFSSAppFabricManagerInfoPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutRedfishV1SFSSAppCDCInstanceManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/CDCInstanceManagers({InstanceId})"
	localVarPath = strings.Replace(localVarPath, "{"+"InstanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putRedfishV1SFSSAppCDCInstanceManagersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRedfishV1SFSSAppIpAddressManagementsRequest struct {
	ctx                                            context.Context
	ApiService                                     *DefaultAPIService
	interfaceId                                    string
	putRedfishV1SFSSAppIpAddressManagementsRequest *PutRedfishV1SFSSAppIpAddressManagementsRequest
}

// {      \&quot;IPV4Address\&quot;: [         \&quot;30.1.1.1\&quot;                                           ],     \&quot;IPV4Config\&quot;: \&quot;MANUAL\&quot;,                    \&quot;IPV4Gateway\&quot;: \&quot;30.1.1.2\&quot;,     \&quot;IPV4PrefixLength\&quot;: 16,     \&quot;IPV6Config\&quot;: \&quot;MANUAL\&quot;,      \&quot;Name\&quot;: \&quot;Name1\&quot;,                     \&quot;IPV6Address\&quot;: [           \&quot;fe80::1699:6fff:43dd:56c1\&quot;               ],      \&quot;IPV6Gateway\&quot;:   \&quot;fe80::1699:6f09:43dd:ffff\&quot;,     \&quot;IPV6PrefixLength\&quot;: 64,      \&quot;MTU\&quot;: 7000 ## If this field is not present, the MTU is chosen as auto  }
func (r ApiPutRedfishV1SFSSAppIpAddressManagementsRequest) PutRedfishV1SFSSAppIpAddressManagementsRequest(putRedfishV1SFSSAppIpAddressManagementsRequest PutRedfishV1SFSSAppIpAddressManagementsRequest) ApiPutRedfishV1SFSSAppIpAddressManagementsRequest {
	r.putRedfishV1SFSSAppIpAddressManagementsRequest = &putRedfishV1SFSSAppIpAddressManagementsRequest
	return r
}

func (r ApiPutRedfishV1SFSSAppIpAddressManagementsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutRedfishV1SFSSAppIpAddressManagementsExecute(r)
}

/*
PutRedfishV1SFSSAppIpAddressManagements Update interface

This API updates the interface information based on the specified interface name. IPv4 and IPv6 route-specific configuration parameters are available from Release 1.3.0 onwards. See example-2 with route configuration for payload details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param interfaceId Interface Name
	@return ApiPutRedfishV1SFSSAppIpAddressManagementsRequest
*/
func (a *DefaultAPIService) PutRedfishV1SFSSAppIpAddressManagements(ctx context.Context, interfaceId string) ApiPutRedfishV1SFSSAppIpAddressManagementsRequest {
	return ApiPutRedfishV1SFSSAppIpAddressManagementsRequest{
		ApiService:  a,
		ctx:         ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) PutRedfishV1SFSSAppIpAddressManagementsExecute(r ApiPutRedfishV1SFSSAppIpAddressManagementsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutRedfishV1SFSSAppIpAddressManagements")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/IpAddressManagements({InterfaceId})"
	localVarPath = strings.Replace(localVarPath, "{"+"InterfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml", "multipart/form-data", "text/html"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putRedfishV1SFSSAppIpAddressManagementsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutRedfishV1SFSSAppNTPRequest struct {
	ctx                           context.Context
	ApiService                    *DefaultAPIService
	putRedfishV1SFSSAppNTPRequest *PutRedfishV1SFSSAppNTPRequest
}

func (r ApiPutRedfishV1SFSSAppNTPRequest) PutRedfishV1SFSSAppNTPRequest(putRedfishV1SFSSAppNTPRequest PutRedfishV1SFSSAppNTPRequest) ApiPutRedfishV1SFSSAppNTPRequest {
	r.putRedfishV1SFSSAppNTPRequest = &putRedfishV1SFSSAppNTPRequest
	return r
}

func (r ApiPutRedfishV1SFSSAppNTPRequest) Execute() (*PutRedfishV1SFSSAppNTP200Response, *http.Response, error) {
	return r.ApiService.PutRedfishV1SFSSAppNTPExecute(r)
}

/*
PutRedfishV1SFSSAppNTP Enable or disable NTP service

This API enables or disables the configured NTP service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutRedfishV1SFSSAppNTPRequest
*/
func (a *DefaultAPIService) PutRedfishV1SFSSAppNTP(ctx context.Context) ApiPutRedfishV1SFSSAppNTPRequest {
	return ApiPutRedfishV1SFSSAppNTPRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PutRedfishV1SFSSAppNTP200Response
func (a *DefaultAPIService) PutRedfishV1SFSSAppNTPExecute(r ApiPutRedfishV1SFSSAppNTPRequest) (*PutRedfishV1SFSSAppNTP200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PutRedfishV1SFSSAppNTP200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PutRedfishV1SFSSAppNTP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/redfish/v1/SFSSApp/NTP"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putRedfishV1SFSSAppNTPRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
